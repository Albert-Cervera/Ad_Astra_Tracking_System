import type { ExtractPropTypes, PropType } from '@vue/runtime-core';
import type { Mutable } from './types';
declare const wrapperKey: unique symbol;
export declare type PropWrapper<T> = {
    [wrapperKey]: T;
};
declare type ResolveProp<T> = ExtractPropTypes<{
    key: {
        type: T;
        required: true;
    };
}>['key'];
declare type ResolvePropType<T> = ResolveProp<T> extends {
    type: infer V;
} ? V : ResolveProp<T>;
declare type ResolvePropTypeWithReadonly<T> = Readonly<T> extends Readonly<Array<infer A>> ? ResolvePropType<A[]> : ResolvePropType<T>;
declare type BuildPropOption<T, D, R, V, C> = {
    type?: T;
    values?: readonly V[];
    required?: R;
    default?: R extends true ? never : D extends Record<string, unknown> | Array<any> ? () => D : D;
    validator?: ((val: any) => val is C) | ((val: any) => boolean);
};
declare type IfUnknown<T, V> = [unknown] extends T ? V : T;
declare type BuildPropType<T, V, C> = (T extends PropWrapper<unknown> ? T[typeof wrapperKey] : [V] extends [never] ? ResolvePropTypeWithReadonly<T> : never) | V | C;
declare type BuildPropDefault<D, R> = R extends true ? {
    readonly default?: undefined;
} : {
    readonly default: Exclude<D, undefined> extends never ? undefined : Exclude<D extends Record<string, unknown> | Array<any> ? () => D : D, undefined>;
};
declare type BuildPropReturn<T, D, R, V, C> = {
    readonly type: PropType<BuildPropType<IfUnknown<T, never>, IfUnknown<V, never>, IfUnknown<C, never>>>;
    readonly required: IfUnknown<R, false>;
    readonly validator: ((val: unknown) => boolean) | undefined;
} & BuildPropDefault<IfUnknown<D, never>, IfUnknown<R, false>>;
export declare function buildProp<T = never, D extends (T extends PropWrapper<any> ? T[typeof wrapperKey] : ResolvePropTypeWithReadonly<T>) | V = never, R extends boolean = false, V = never, C = never>(option?: BuildPropOption<T, D, R, V, C>): BuildPropReturn<T, D, R, V, C>;
export declare const buildProps: <O extends Record<string, BuildPropOption<any, any, any, any, any>>>(options: O) => { [K in keyof O]: O[K] extends BuildPropOption<infer T, infer D, infer R, infer V, infer C> ? BuildPropReturn<T, D, R, V, C> : never; };
export declare const definePropType: <T>(val: any) => PropWrapper<T>;
export declare const keyOf: <T>(arr: T) => (keyof T)[];
export declare const mutable: <T extends readonly any[] | Record<string, unknown>>(val: T) => Mutable<T>;
export declare const componentSize: readonly ["large", "medium", "small", "mini"];
export {};
